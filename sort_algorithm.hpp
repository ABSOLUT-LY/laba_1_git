#include "array_processor.hpp" //импорт для проверок на валидность
#pragma once                   // предотвращает многократное включение этого файла при импорте
// класс содержащий в себе алгоритмы сортировки

/*Здесь хранятся только алгоритмы сортировки*/

class SortAlgorithm
{
public:
    // функция вызова сортировки
    static double *quick_sort(double *arr_for_sort, int n)
    {
        double *result = new double[n]; // копируем начальным массив
        for (int i = 0; i < n; i++)
        {
            result[i] = arr_for_sort[i];
        }
        SortAlgorithm::quick_sort_method(result, 0, n - 1); // вызываем сортировку
        return result;                                      // возвращаем новый массив не меняя старого
    }
    /*алгоритм направлен на поиск двух элементов для обмена мутем уменьшения области поиска путем рекурсии.
     На каждом из этапов работы алгоритм сравнивает элементы с пивотом - произвольным элементом массива.
     В нашем случае серидиной, если больше то вправо , если меньше то влево.
     Процесс рекурсивно повторяется для каждого подмассива, пока их длина не будет равна 1
     На выходе получается отсортированный по возрастанию массив*/
private:
    static void quick_sort_method(double *array, int low, int high)
    {
        // проверка корректности границ
        if (ArrayProcessor::should_stop_sort(low, high))
        {
            return; // выход если границы массива неверны
        }
        int i = low;                              // левый указатель на элемент массива
        int j = high;                             // правый указатель на элемент массива
        double pivot = array[(int)((i + j) / 2)]; // пивот - у нас середина, првиедет к типу int , чтобы избажть дроби
        double temp;                              // временным элемент буфер для смены элементов местами
        while (i <= j)                            // пока указаетли не встретятся
        {
            while (array[i] < pivot) // пока элемент < пивот - движемся влево
                i++;
            while (array[j] > pivot) // пока элемент > пивот - движемся вправо
                j--;
            if (i <= j) /* если встретились или остановились , то меняем элементы местами.
                           Таким образом меньший переместится влево, а больший вправо*/
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }
        // проверка, чтобы указатели на индексы не выходили за границы, если будут равны, то массив из одного элемента - действий не требуется
        if (j > low)
            SortAlgorithm::quick_sort_method(array, low, j);
        if (i < high)
            SortAlgorithm::quick_sort_method(array, i, high);
    }
};